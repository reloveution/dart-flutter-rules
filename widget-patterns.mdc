---
description: "Flutter widget development rules. Covers build method optimization, widget composition, context handling, and controller injection patterns for maintainable UI code."
globs:
alwaysApply: true
---

# Widget Pattern Rules

- Widgets are for UI: Everything in Flutter's UI is a widget. Compose complex UIs from smaller, reusable widgets.
- Avoid long methods and complex logic in build methods, onPressed callbacks, and similar UI handlers. Extract complex logic into separate methods.
- Extract string concatenations into dedicated methods instead of inline operations.
- **List Performance:** Use `ListView.builder` or `SliverList` for long lists to create lazy-loaded lists for performance.
- **Isolates:** Use `compute()` to run expensive calculations in a separate isolate to avoid blocking the UI thread, such as JSON parsing.
- **Immutability:** Widgets (especially `StatelessWidget`) are immutable; when the UI needs to change, Flutter rebuilds the widget tree.
- **Composition:** Prefer composing smaller widgets over extending existing ones. Use this to avoid deep widget nesting.
- Create separate widgets instead of methods that return widgets. Avoid widget-returning methods in widget classes.
- Never use Container widget. Use specific widgets instead:
  - Use `SizedBox.shrink()` or `SizedBox.expand()` instead of empty Container
  - Use `ColoredBox` instead of Container with only color property
  - Use `DecoratedBox` instead of Container with only decoration property
  - Combine widgets when multiple properties are needed
- WidgetsBinding.instance.addPostFrameCallback should be used extremely rarely and only where it is truly necessary.
- Always verify widget context exists before creating dialogs. Check context.mounted before accessing context-dependent operations to prevent 'context not found' errors (use_build_context_synchronously).
- Pass callback functions (events or controller methods) to reusable widgets instead of passing state managers directly.
- When injecting controllers into context through providers, get controllers from DI. When accessing in widget tree, get controllers from context, not from DI.
- In dialogs and context changes, pass controller methods instead of controllers themselves.
- Use keys for widgets that need to maintain state across rebuilds (use_key_in_widget_constructors)
- Use proper theme inheritance instead of hardcoded colors and styles
- Use full hex values for Flutter colors (8 digits: AARRGGBB) instead of 6-digit hex
- Implement responsive design with MediaQuery and LayoutBuilder
- Implement proper loading states and error handling in UI components
- Use RepaintBoundary for expensive custom painters
- Use AnimatedBuilder for complex animations
- Implement proper gesture handling with GestureDetector
- Use proper focus management for form inputs
- Avoid logic in createState() methods - keep them simple and focused
- Use proper navigation patterns (GoRouter, AutoRouter, Navigator 2.0) instead of Navigator.push/pop. See navigation best practices for detailed examples.
- Use proper form validation with FormField widgets
- Implement proper keyboard handling and input actions
- Use proper scroll physics for different content types
- Implement proper image loading with error handling
- Cancel subscriptions when leaving widgets or pages to prevent memory leaks (cancel_subscriptions)
- Avoid web libraries in Flutter applications - use Flutter-specific alternatives (avoid_web_libraries_in_flutter)

## When the project uses GoRouter

- **GoRouter:** Use the `go_router` package for declarative navigation, deep linking, and web support.
- **GoRouter Setup:** To use `go_router`, first add it to your `pubspec.yaml` using the `pub` tool's `add` command.

```dart
// 1. Add the dependency
// flutter pub add go_router

// 2. Configure the router
final GoRouter _router = GoRouter(
  routes: <RouteBase>[
    GoRoute(
      path: '/',
      builder: (context, state) => const HomeScreen(),
      routes: <RouteBase>[
        GoRoute(
          path: 'details/:id', // Route with a path parameter
          builder: (context, state) {
            final String id = state.pathParameters['id']!;
            return DetailScreen(id: id);
          },
        ),
      ],
    ),
  ],
);

// 3. Use it in your MaterialApp
MaterialApp.router(
  routerConfig: _router,
);
```

- **Authentication Redirects:** Configure `go_router`'s `redirect` property to handle authentication flows, ensuring users are redirected to the login screen when unauthorized, and back to their intended destination after successful login.
- **Navigator:** Use the built-in `Navigator` for short-lived screens that do not need to be deep-linkable, such as dialogs or temporary views.

```dart
// Push a new screen onto the stack
Navigator.push(
  context,
  MaterialPageRoute(builder: (context) => const DetailsScreen()),
);

// Pop the current screen to go back
Navigator.pop(context);
```

## Layout Best Practices

### Building Flexible and Overflow-Safe Layouts
### Common Flutter Errors
- "RenderFlex overflowed": проверяй, не содержат ли Row/Column неограниченные дочерние виджеты; оборачивай элементы в Flexible или Expanded либо задавай явные ограничения.
- "Vertical viewport was given unbounded height": если ListView/Scrollable внутри Column, обеспечь им ограничение по высоте (Expanded, SizedBox, SliverFillRemaining и т.п.).
- "An InputDecorator...cannot have an unbounded width": ограничь ширину TextField и других InputDecorator через Expanded, SizedBox либо родитель с фиксированной шириной.
- "setState called during build": не вызывай setState/showDialog напрямую в build; переносись в колбэки пользователя или отложи выполнение (например, через addPostFrameCallback при строгой необходимости).
- "ScrollController attached to multiple scroll views": используй отдельный ScrollController на каждую прокручиваемую область либо отсоединяй перед повторным использованием.
- "RenderBox was not laid out": найдя виджеты без ограничений (часто ListView/Column), задай им размеры или оберни в виджеты, передающие constraints.
- При макетных сбоях включай Flutter Inspector и анализируй цепочку ограничений; при необходимости перечитай официальную документацию по layout constraints.

#### For Rows and Columns

- **`Expanded`:** Use to make a child widget fill the remaining available space along the main axis.
- **`Flexible`:** Use when you want a widget to shrink to fit, but not necessarily grow. Don't combine `Flexible` and `Expanded` in the same `Row` or `Column`.
- **`Wrap`:** Use when you have a series of widgets that would overflow a `Row` or `Column`, and you want them to move to the next line.

#### For General Content

- **`SingleChildScrollView`:** Use when your content is intrinsically larger than the viewport, but is a fixed size.
- **`ListView` / `GridView`:** For long lists or grids of content, always use a builder constructor (`.builder`).
- **`FittedBox`:** Use to scale or fit a single child widget within its parent.
- **`LayoutBuilder`:** Use for complex, responsive layouts to make decisions based on the available space.

### Layering Widgets with Stack

- **`Positioned`:** Use to precisely place a child within a `Stack` by anchoring it to the edges.
- **`Align`:** Use to position a child within a `Stack` using alignments like `Alignment.center`.

### Advanced Layout with Overlays

- **`OverlayPortal`:** Use this widget to show UI elements (like custom dropdowns or tooltips) "on top" of everything else. It manages the `OverlayEntry` for you.

```dart
class MyDropdown extends StatefulWidget {
  const MyDropdown({super.key});

  @override
  State<MyDropdown> createState() => _MyDropdownState();
}

class _MyDropdownState extends State<MyDropdown> {
  final _controller = OverlayPortalController();

  @override
  Widget build(BuildContext context) {
    return OverlayPortal(
      controller: _controller,
      overlayChildBuilder: (BuildContext context) {
        return const Positioned(
          top: 50,
          left: 10,
          child: Card(
            child: Padding(
              padding: EdgeInsets.all(8.0),
              child: Text('I am an overlay!'),
            ),
          ),
        );
      },
      child: ElevatedButton(
        onPressed: _controller.toggle,
        child: const Text('Toggle Overlay'),
      ),
    );
  }
}
```

## Visual Design & Theming
- **UI Design:** Build beautiful and intuitive user interfaces that follow modern design guidelines.
- **Responsiveness:** Ensure the app is mobile responsive and adapts to different screen sizes, working perfectly on mobile and web. Use `LayoutBuilder` or `MediaQuery` to create responsive UIs.
- **Text:** Use `Theme.of(context).textTheme` for text styles.
- **Text Fields:** Configure `textCapitalization`, `keyboardType`, and other input properties appropriately for the input type.
- **Navigation:** If there are multiple pages for the user to interact with, provide an intuitive and easy navigation bar or controls.
- **Typography:** Stress and emphasize font sizes to ease understanding, e.g., hero text, section headlines, list headlines, keywords in paragraphs.
- **Background:** Apply subtle noise texture to the main background to add a premium, tactile feel.
- **Shadows:** Multi-layered drop shadows create a strong sense of depth; cards have a soft, deep shadow to look "lifted."
- **Icons:** Incorporate icons to enhance the user's understanding and the logical navigation of the app.
- **Interactive Elements:** Buttons, checkboxes, sliders, lists, charts, graphs, and other interactive elements have a shadow with elegant use of color to create a "glow" effect.

### Theming
- **Centralized Theme:** Define a centralized `ThemeData` object to ensure a consistent application-wide style.
- **Light and Dark Themes:** Implement support for both light and dark themes, ideal for a user-facing theme toggle (`ThemeMode.light`, `ThemeMode.dark`, `ThemeMode.system`).
- **Color Scheme Generation:** Generate harmonious color palettes from a single color using `ColorScheme.fromSeed`.

```dart
final ThemeData lightTheme = ThemeData(
  colorScheme: ColorScheme.fromSeed(
    seedColor: Colors.deepPurple,
    brightness: Brightness.light,
  ),
  // ... other theme properties
);
```

- **Color Palette:** Include a wide range of color concentrations and hues in the palette to create a vibrant and energetic look and feel.
- **Component Themes:** Use specific theme properties (e.g., `appBarTheme`, `elevatedButtonTheme`) to customize the appearance of individual Material components.
- **Custom Fonts:** For custom fonts, use the `google_fonts` package. Define a `TextTheme` to apply fonts consistently.

```dart
// 1. Add the dependency
// flutter pub add google_fonts

// 2. Define a TextTheme with a custom font
final TextTheme appTextTheme = TextTheme(
  displayLarge: GoogleFonts.oswald(fontSize: 57, fontWeight: FontWeight.bold),
  titleLarge: GoogleFonts.roboto(fontSize: 22, fontWeight: FontWeight.w500),
  bodyMedium: GoogleFonts.openSans(fontSize: 14),
);
```

### Font Best Practices

#### Font Selection

- **Limit Font Families:** Stick to one or two font families for the entire application.
- **Prioritize Legibility:** Choose fonts that are easy to read on screens of all sizes. Sans-serif fonts are generally preferred for UI body text.
- **System Fonts:** Consider using platform-native system fonts.
- **Google Fonts:** For a wide selection of open-source fonts, use the `google_fonts` package.

#### Hierarchy and Scale

- **Establish a Scale:** Define a set of font sizes for different text elements (e.g., headlines, titles, body text, captions).
- **Use Font Weight:** Differentiate text effectively using font weights.
- **Color and Opacity:** Use color and opacity to de-emphasize less important text.

#### Readability

- **Line Height (Leading):** Set an appropriate line height, typically **1.4x to 1.6x** the font size.
- **Line Length:** For body text, aim for a line length of **45-75 characters**.
- **Avoid All Caps:** Do not use all caps for long-form text.

#### Example Typographic Scale

```dart
// In your ThemeData
textTheme: const TextTheme(
  displayLarge: TextStyle(fontSize: 57.0, fontWeight: FontWeight.bold),
  titleLarge: TextStyle(fontSize: 22.0, fontWeight: FontWeight.bold),
  bodyLarge: TextStyle(fontSize: 16.0, height: 1.5),
  bodyMedium: TextStyle(fontSize: 14.0, height: 1.4),
  labelSmall: TextStyle(fontSize: 11.0, color: Colors.grey),
),
```

### Material Theming Best Practices

### Material Theming Best Practices

#### Embrace `ThemeData` and Material 3

- **Use `ColorScheme.fromSeed()`:** Use this to generate a complete, harmonious color palette for both light and dark modes from a single seed color.
- **Define Light and Dark Themes:** Provide both `theme` and `darkTheme` to your `MaterialApp` to support system brightness settings seamlessly.
- **Centralize Component Styles:** Customize specific component themes (e.g., `elevatedButtonTheme`, `cardTheme`, `appBarTheme`) within `ThemeData` to ensure consistency.
- **Dark/Light Mode and Theme Toggle:** Implement support for both light and dark themes using `theme` and `darkTheme` properties of `MaterialApp`. The `themeMode` property can be dynamically controlled (e.g., via a `ChangeNotifierProvider`) to allow for toggling between `ThemeMode.light`, `ThemeMode.dark`, or `ThemeMode.system`.

```dart
// main.dart
MaterialApp(
  theme: ThemeData(
    colorScheme: ColorScheme.fromSeed(
      seedColor: Colors.deepPurple,
      brightness: Brightness.light,
    ),
    textTheme: const TextTheme(
      displayLarge: TextStyle(fontSize: 57.0, fontWeight: FontWeight.bold),
      bodyMedium: TextStyle(fontSize: 14.0, height: 1.4),
    ),
  ),
  darkTheme: ThemeData(
    colorScheme: ColorScheme.fromSeed(
      seedColor: Colors.deepPurple,
      brightness: Brightness.dark,
    ),
  ),
  home: const MyHomePage(),
);
```

#### Implement Design Tokens with `ThemeExtension`

For custom styles that aren't part of the standard `ThemeData`, use `ThemeExtension` to define reusable design tokens.

- **Create a Custom Theme Extension:** Define a class that extends `ThemeExtension<T>` and include your custom properties.
- **Implement `copyWith` and `lerp`:** These methods are required for the extension to work correctly with theme transitions.
- **Register in `ThemeData`:** Add your custom extension to the `extensions` list in your `ThemeData`.
- **Access Tokens in Widgets:** Use `Theme.of(context).extension<MyColors>()!` to access your custom tokens.

```dart
// 1. Define the extension
@immutable
class MyColors extends ThemeExtension<MyColors> {
  const MyColors({required this.success, required this.danger});

  final Color? success;
  final Color? danger;

  @override
  ThemeExtension<MyColors> copyWith({Color? success, Color? danger}) {
    return MyColors(success: success ?? this.success, danger: danger ?? this.danger);
  }

  @override
  ThemeExtension<MyColors> lerp(ThemeExtension<MyColors>? other, double t) {
    if (other is! MyColors) return this;
    return MyColors(
      success: Color.lerp(success, other.success, t),
      danger: Color.lerp(danger, other.danger, t),
    );
  }
}

// 2. Register it in ThemeData
theme: ThemeData(
  extensions: const <ThemeExtension<dynamic>>[
    MyColors(success: Colors.green, danger: Colors.red),
  ],
),

// 3. Use it in a widget
Container(
  color: Theme.of(context).extension<MyColors>()!.success,
)
```

#### Styling with `WidgetStateProperty`

- **`WidgetStateProperty.resolveWith`:** Provide a function that receives a `Set<WidgetState>` and returns the appropriate value for the current state.
- **`WidgetStateProperty.all`:** A shorthand for when the value is the same for all states.

```dart
// Example: Creating a button style that changes color when pressed.
final ButtonStyle myButtonStyle = ButtonStyle(
  backgroundColor: WidgetStateProperty.resolveWith<Color>(
    (Set<WidgetState> states) {
      if (states.contains(WidgetState.pressed)) {
        return Colors.green; // Color when pressed
      }
      return Colors.red; // Default color
    },
  ),
);
```

## Accessibility (A11Y)
Implement accessibility features to empower all users, assuming a wide variety of users with different physical abilities, mental abilities, age groups, education levels, and learning styles.
- **Color Contrast:** Ensure text has a contrast ratio of at least **4.5:1** against its background.
- **Dynamic Text Scaling:** Test your UI to ensure it remains usable when users increase the system font size.
- **Semantic Labels:** Use the `Semantics` widget to provide clear, descriptive labels for UI elements.
- **Screen Reader Testing:** Regularly test your app with TalkBack (Android) and VoiceOver (iOS).

## Assets and Images
- **Image Guidelines:** If images are needed, make them relevant and meaningful, with appropriate size, layout, and licensing (e.g., freely available). Provide placeholder images if real ones are not available.
- **Asset Declaration:** Declare all asset paths in your `pubspec.yaml` file.

```yaml
flutter:
  uses-material-design: true
  assets:
    - assets/images/
```

- **Local Images:** Use `Image.asset` for local images from your asset bundle.

```dart
Image.asset('assets/images/placeholder.png')
```

- **Network Images:** Use `NetworkImage` for images loaded from the network.
- **Cached Images:** For cached images, use NetworkImage a package like `cached_network_image`.
- **Custom Icons:** Use `ImageIcon` to display an icon from an `ImageProvider`, useful for custom icons not in the `Icons` class.
- **Network Images:** Use `Image.network` to display images from a URL, and always include `loadingBuilder` and `errorBuilder` for a better user experience.

```dart
Image.network(
  'https://picsum.photos/200/300',
  loadingBuilder: (context, child, progress) {
    if (progress == null) return child;
    return const Center(child: CircularProgressIndicator());
  },
  errorBuilder: (context, error, stackTrace) {
    return const Icon(Icons.error);
  },
)
```
