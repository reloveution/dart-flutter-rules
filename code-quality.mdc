---
description: "Core code quality rules for clean, maintainable Dart/Flutter code. Covers async/await, null safety, const constructors, error handling, class member ordering, and general best practices."
globs:
alwaysApply: true
---

# Code Quality Rules

## Logging & Debugging
- **Trailing Comments:** Don't add trailing comments.
- Do not leave print or debugPrint statements in production code. Do not remove log() calls when cleaning print/debugPrint statements, as log() is used for structured logging.
- Implement proper logging levels (debug, info, warning, error) instead of print statements
- Do not add new comments in code. Only TODO comments in English are allowed. Do not modify existing comments.
- Implement proper toString() methods for debugging
- Use assert statements for development-time checks
- Logging Package: Use the `logging` package instead of `print` statements.
- **Structured Logging:** Use the `log` function from `dart:developer` for structured logging that integrates with Dart DevTools.

```dart
import 'dart:developer' as developer;

// For simple messages
developer.log('User logged in successfully.');

// For structured error logging
try {
  // ... code that might fail
} catch (e, s) {
  developer.log(
    'Failed to fetch data',
    name: 'myapp.network',
    level: 1000, // SEVERE
    error: e,
    stackTrace: s,
  );
}
```

## Code Quality Tools
- **Formatting:** Use the `dart_format` tool to ensure consistent code formatting.
- **Fixes:** Use the `dart_fix` tool to automatically fix many common errors, and to help code conform to configured analysis options.
- **Linting:** Use the Dart linter with a recommended set of rules to catch common issues. Use the `analyze_files` tool to run the linter.
- **Lint Rules:** Include the `flutter_lints` package in the `analysis_options.yaml` file. Use the following analysis_options.yaml file as a starting point:
```yaml
include: package:flutter_lints/flutter.yaml
linter:
  rules:
    # Add additional lint rules here:
    # avoid_print: false
    # prefer_single_quotes: true
```

## Code Generation
- **Build Runner:** If the project uses code generation, ensure that `build_runner` is listed as a dev dependency in `pubspec.yaml`.
- **Code Generation Tasks:** Use `build_runner` for all code generation tasks, such as for `json_serializable`.
- **Running Build Runner:** After modifying files that require code generation, run the build command:

```shell
dart run build_runner build --delete-conflicting-outputs
```


## Code Styling
- Line Length: Lines should be 80 characters or fewer.
- Naming Conventions: Use `PascalCase` for classes, `camelCase` for members/variables/functions/enums, and `snake_case` for files.

## Dart Best Practices
- **Effective Dart:** Follow the official Effective Dart guidelines (https://dart.dev/effective-dart).
- **Pattern Matching:** Use pattern matching features where they simplify the code.
- **Records:** Use records to return multiple types in situations where defining an entire class is cumbersome.
- **Switch Statements:** Prefer using exhaustive `switch` statements or expressions, which don't require `break` statements.
- **Streams:** Use `Stream`s for sequences of asynchronous events.

## Code Organization & Documentation
- **Class Organization:** Define related classes within the same library file. For large libraries, export smaller, private libraries from a single top-level library.
- **Library Organization:** Group related libraries in the same folder.
- **API Documentation:** Add documentation comments to all public APIs, including classes, constructors, methods, and top-level functions.

## Documentation
- **`dartdoc`:** Write `dartdoc`-style comments for all public APIs.

### Documentation Philosophy
- **Comment wisely:** Use comments to explain why the code is written a certain way, not what the code does. The code itself should be self-explanatory.
- **Document for the user:** Write documentation with the reader in mind. If you had a question and found the answer, add it to the documentation where you first looked. This ensures the documentation answers real-world questions.
- **No useless documentation:** If the documentation only restates the obvious from the code's name, it's not helpful. Good documentation provides context and explains what isn't immediately apparent.
- **Consistency is key:** Use consistent terminology throughout your documentation.

### Commenting Style
- **Use `///` for doc comments:** This allows documentation generation tools to pick them up.
- **Start with a single-sentence summary:** The first sentence should be a concise, user-centric summary ending with a period.
- **Separate the summary:** Add a blank line after the first sentence to create a separate paragraph. This helps tools create better summaries.
- **Avoid redundancy:** Don't repeat information that's obvious from the code's context, like the class name or signature.
- **Don't document both getter and setter:** For properties with both, only document one. The documentation tool will treat them as a single field.

### Writing Style
- **Be brief:** Write concisely.
- **Avoid jargon and acronyms:** Don't use abbreviations unless they are widely understood.
- **Use Markdown sparingly:** Avoid excessive markdown and never use HTML for formatting.
- **Use backticks for code:** Enclose code blocks in backtick fences, and specify the language.

### What to Document
- **Public APIs are a priority:** Always document public APIs.
- **Consider private APIs:** It's a good idea to document private APIs as well.
- **Library-level comments are helpful:** Consider adding a doc comment at the library level to provide a general overview.
- **Include code samples:** Where appropriate, add code samples to illustrate usage.
- **Explain parameters, return values, and exceptions:** Use prose to describe what a function expects, what it returns, and what errors it might throw.
- **Place doc comments before annotations:** Documentation should come before any metadata annotations.

## API Design Principles
When building reusable APIs, such as a library, follow these principles:
- **Consider the User:** Design APIs from the perspective of the person who will be using them. The API should be intuitive and easy to use correctly.
- **Documentation is Essential:** Good documentation is a part of good API design. It should be clear, concise, and provide examples.

## Conciseness
- Write code that is as short as it can be while remaining clear.

## Strings & Localization
- Extract all user-facing strings to localization files immediately. Do not hardcode strings in code.

## Async/Await
- Always use async/await instead of .then() for asynchronous operations.
- **Future/Async/Await:** Use `Future`s, `async`, and `await` for asynchronous operations.
- **Streams:** Use `Stream`s for sequences of asynchronous events.
- Avoid blocking the UI thread. Use async/await for I/O operations, consider using isolates for CPU-intensive tasks.
- Don't use async/await for simple Future pass-through. Use arrow function syntax when only returning a Future:
  Bad: `Future<T> method() async { return await other(); }`
  Good: `Future<T> method() => other();`
  Use async/await only when processing results, handling errors, or performing additional operations.

## Functions & Callbacks
- Prefer arrow functions where applicable. Use arrow functions for single-expression functions and callbacks.
- For widget build methods and BlocBuilder callbacks, prefer arrow functions with ternary operators over if-else blocks. Replace unused callback parameters with underscore (_).
- Use extension methods for utility functions instead of static methods
- Avoid using static methods for business logic
- Prefer named parameters for functions with more than 2 parameters
- Use typedef for complex function signatures to improve readability
- Use generic function type syntax in typedefs: typedef ImageProviderFunction<T> = ImageProvider Function(T item) instead of older syntax variants.
- Function Length: Functions should be short and with a single purpose. Strive for less than 20 lines per function.

## Null Safety
- Write code that is soundly null-safe. Leverage Dart's null safety features.
- Avoid `!` unless the value is guaranteed to be non-null.
- Use null-aware operators and avoid redundant null checks. Prefer ?. and ?? operators over explicit if-null checks. Use ?? operator instead of if-null blocks for simple value assignments. Remove redundant empty else blocks.
- Always check for null data before using it. Use explicit null checks instead of force unwrapping with ! operator.
- Implement proper null safety patterns throughout the codebase

## Control Flow & Readability
- Use single-line early returns instead of block statements for simple conditions.
- Use Guard Clauses (early returns) to reduce nesting and improve readability. Validate preconditions at the start of methods with inverted conditions and return early for invalid cases. This keeps the main logic at the lowest nesting level and makes method requirements explicit:
  Bad: `if (state is Loaded) { /* main logic nested */ }`
  Good: `if (state is! Loaded) return; /* main logic at root level */`
  Prefer `is!` operator for readability over `!(x is Type)`.
- Don't use explicit boolean comparisons (`== true` or `== false`) with boolean expressions. Boolean values should be used directly in conditions.
  Bad: `if (isValid == true) { }`, `final result = value == false ? a : b`
  Good: `if (isValid) { }`, `final result = value ? a : b`, `if (!isValid) { }`
  Exception: Nullable booleans (`bool?`) may require `== true` to distinguish between true, false, and null: `if (maybeTrue == true) { }` is different from `if (maybeTrue ?? false) { }`.

## Performance
- Avoid expensive operations in build methods.
- Use const constructors everywhere possible for performance optimization. Apply to UI widgets when data is static, not to business logic methods.
- Use const constructors for immutable objects

## Constructors & Initialization
- Use late initialization for non-null variables that are initialized after construction
- Use factory constructors for complex object creation

## Variables & Mutability
- Prefer final variables over var when the value won't change
- Prefer final variables with ternary/conditional expressions over mutable variables changed in if-else blocks. This ensures all possible values are explicit and prevents missed assignments:
  Bad: `int val = x; if (cond) { val = y; }`
  Good: `final int val = cond ? y : x;`
  For complex conditions, extract calculation into a separate method.

## Type Safety
- Avoid using dynamic type - use proper type annotations
- Use sealed classes for state management instead of free classes when possible

## Data Processing
- Use functional programming methods (map, where, fold) instead of imperative loops for data transformations.
- Use Duration constructor with milliseconds for consistency, as most APIs return values in milliseconds.
- Use cascade operators (..) for method chaining when appropriate

## Utilities & Helpers
- Use getters instead of parameterless methods for object properties.
- Use `.byName()` for parsing enum from strings instead of hardcoded string literals. Don't create intermediate variable if used only once, unless needed for logging or multiple uses.
  Bad: `case 'text': return TextParam.fromJson(json);`
  Good: `switch (ParamType.values.byName(json['type'] as String)) { case ParamType.text: return TextParam.fromJson(json); }`

## Constants & Magic Numbers
- Avoid magic numbers. Use constants from AppConstants instead. Add new constants to AppConstants when needed.

## Error Handling
- Handle errors gracefully in UI. Show user-friendly messages, never expose technical details to users.
- Implement proper error boundaries with fallback UI components

## Code Organization
- Avoid deep nesting - extract methods when nesting exceeds 3 levels
- Use meaningful variable names that describe their purpose
- Follow DRY (Don't Repeat Yourself) principle - eliminate code duplication
- Extract common functionality into reusable components

## Testing
- **Running Tests:** To run tests, use the `run_tests` tool if it is available, otherwise use `flutter test`.
- **Unit Tests:** Use `package:test` for unit tests.
- **Widget Tests:** Use `package:flutter_test` for widget tests.
- **Integration Tests:** Use `package:integration_test` for integration tests.
- **Assertions:** Prefer using `package:checks` for more expressive and readable assertions over the default `matchers`.
- **Testability:** Write code with testing in mind. Use the `file`, `process`, and `platform` packages, if appropriate, so you can inject in-memory and fake versions of the objects.
- Design classes and functions to be easily testable by allowing dependency injection.
- Keep business logic separate from framework-specific code to enable unit testing.

### Testing Best Practices
- **Convention:** Follow the Arrange-Act-Assert (or Given-When-Then) pattern.
- **Unit Tests:** Write unit tests for domain logic, data layer, and state management.
- **Widget Tests:** Write widget tests for UI components.
- **Integration Tests:** For broader application validation, use integration tests to verify end-to-end user flows.
- **integration_test package:** Use the `integration_test` package from the Flutter SDK for integration tests. Add it as a `dev_dependency` in `pubspec.yaml` by specifying `sdk: flutter`.
- **Mocks:** Prefer fakes or stubs over mocks. If mocks are absolutely necessary, use `mockito` or `mocktail` to create mocks for dependencies. While code generation is common for state management (e.g., with `freezed`), try to avoid it for mocks.
- **Coverage:** Aim for high test coverage.

## Class Member Declaration Order

### Required Order:
1. **Static constants** (static const)
2. **Class fields** (final â†’ regular fields)  
3. **Constructor**
4. **Getters/Setters**
5. **Lifecycle methods** (initState, dispose, etc.)
6. **Override methods** (methods with @override annotation)
7. **Public methods**
8. **Private methods**

### Internal Methods (Helper Methods):
- Internal methods (written to break down long methods) go **after** external methods
- Grouped at the end of the corresponding section (public/private)

### Formatting:
- Add empty lines between logical groups of methods
- Group related methods together
- Follow single responsibility principle