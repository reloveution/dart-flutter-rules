---
description: "Core code quality rules for clean, maintainable Dart/Flutter code. Covers async/await, null safety, const constructors, error handling, class member ordering, and general best practices."
globs:
alwaysApply: true
---

# Code Quality Rules

## Logging & Debugging
- Do not leave print or debugPrint statements in production code. Do not remove log() calls when cleaning print/debugPrint statements, as log() is used for structured logging.
- Implement proper logging levels (debug, info, warning, error) instead of print statements
- Do not add new comments in code. Only TODO comments in English are allowed. Do not modify existing comments.
- Implement proper toString() methods for debugging
- Use assert statements for development-time checks

## Strings & Localization
- Extract all user-facing strings to localization files immediately. Do not hardcode strings in code.

## Async/Await
- Always use async/await instead of .then() for asynchronous operations.
- Avoid blocking the UI thread. Use async/await for I/O operations, consider using isolates for CPU-intensive tasks.
- Don't use async/await for simple Future pass-through. Use arrow function syntax when only returning a Future:
  Bad: `Future<T> method() async { return await other(); }`
  Good: `Future<T> method() => other();`
  Use async/await only when processing results, handling errors, or performing additional operations.

## Functions & Callbacks
- Prefer arrow functions where applicable. Use arrow functions for single-expression functions and callbacks.
- For widget build methods and BlocBuilder callbacks, prefer arrow functions with ternary operators over if-else blocks. Replace unused callback parameters with underscore (_).
- Use extension methods for utility functions instead of static methods
- Avoid using static methods for business logic
- Prefer named parameters for functions with more than 2 parameters
- Use typedef for complex function signatures to improve readability
- Use generic function type syntax in typedefs: typedef ImageProviderFunction<T> = ImageProvider Function(T item) instead of older syntax variants.

## Null Safety
- Use null-aware operators and avoid redundant null checks. Prefer ?. and ?? operators over explicit if-null checks. Use ?? operator instead of if-null blocks for simple value assignments. Remove redundant empty else blocks.
- Always check for null data before using it. Use explicit null checks instead of force unwrapping with ! operator.
- Implement proper null safety patterns throughout the codebase

## Control Flow & Readability
- Use single-line early returns instead of block statements for simple conditions.
- Use Guard Clauses (early returns) to reduce nesting and improve readability. Validate preconditions at the start of methods with inverted conditions and return early for invalid cases. This keeps the main logic at the lowest nesting level and makes method requirements explicit:
  Bad: `if (state is Loaded) { /* main logic nested */ }`
  Good: `if (state is! Loaded) return; /* main logic at root level */`
  Prefer `is!` operator for readability over `!(x is Type)`.
- Don't use explicit boolean comparisons (`== true` or `== false`) with boolean expressions. Boolean values should be used directly in conditions.
  Bad: `if (isValid == true) { }`, `final result = value == false ? a : b`
  Good: `if (isValid) { }`, `final result = value ? a : b`, `if (!isValid) { }`
  Exception: Nullable booleans (`bool?`) may require `== true` to distinguish between true, false, and null: `if (maybeTrue == true) { }` is different from `if (maybeTrue ?? false) { }`.

## Performance
- Avoid expensive operations in build methods.
- Use const constructors everywhere possible for performance optimization. Apply to UI widgets when data is static, not to business logic methods.
- Use const constructors for immutable objects

## Constructors & Initialization
- Use late initialization for non-null variables that are initialized after construction
- Use factory constructors for complex object creation

## Variables & Mutability
- Prefer final variables over var when the value won't change
- Prefer final variables with ternary/conditional expressions over mutable variables changed in if-else blocks. This ensures all possible values are explicit and prevents missed assignments:
  Bad: `int val = x; if (cond) { val = y; }`
  Good: `final int val = cond ? y : x;`
  For complex conditions, extract calculation into a separate method.

## Type Safety
- Avoid using dynamic type - use proper type annotations
- Use sealed classes for state management instead of free classes when possible

## Data Processing
- Use functional programming methods (map, where, fold) instead of imperative loops for data transformations.
- Use Duration constructor with milliseconds for consistency, as most APIs return values in milliseconds.
- Use cascade operators (..) for method chaining when appropriate

## Utilities & Helpers
- Use getters instead of parameterless methods for object properties.
- Use `.byName()` for parsing enum from strings instead of hardcoded string literals. Don't create intermediate variable if used only once, unless needed for logging or multiple uses.
  Bad: `case 'text': return TextParam.fromJson(json);`
  Good: `switch (ParamType.values.byName(json['type'] as String)) { case ParamType.text: return TextParam.fromJson(json); }`

## Constants & Magic Numbers
- Avoid magic numbers. Use constants from AppConstants instead. Add new constants to AppConstants when needed.

## Error Handling
- Handle errors gracefully in UI. Show user-friendly messages, never expose technical details to users.
- Implement proper error boundaries with fallback UI components

## Code Organization
- Avoid deep nesting - extract methods when nesting exceeds 3 levels
- Use meaningful variable names that describe their purpose
- Follow DRY (Don't Repeat Yourself) principle - eliminate code duplication
- Extract common functionality into reusable components

## Class Member Declaration Order

### Required Order:
1. **Static constants** (static const)
2. **Class fields** (final â†’ regular fields)  
3. **Constructor**
4. **Getters/Setters**
5. **Lifecycle methods** (initState, dispose, etc.)
6. **Override methods** (methods with @override annotation)
7. **Public methods**
8. **Private methods**

### Internal Methods (Helper Methods):
- Internal methods (written to break down long methods) go **after** external methods
- Grouped at the end of the corresponding section (public/private)

### Formatting:
- Add empty lines between logical groups of methods
- Group related methods together
- Follow single responsibility principle