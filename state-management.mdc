---
description: "State management best practices and patterns for Flutter applications. Covers immutable state, serialization, persistence, BLoC patterns, and state synchronization."
globs:
alwaysApply: true
---

# State Management Rules

## General State Management
- **State Separation:** Separate ephemeral state and app state. Use a state management solution for app state to handle the separation of concerns.
- Keep state immutable and use copyWith methods for updates
- Implement proper state serialization for app lifecycle management
- Use proper state hydration for app restoration
- Implement proper state persistence for offline functionality
- Use proper state synchronization between multiple instances
- Implement proper state validation and sanitization
- Avoid using global variables for state management
- Use a single state management approach per widget

## BLoC Pattern
- Bloc events should be generated only through bloc methods, not directly from view. View should call bloc methods (e.g., loadData(), saveData()) that internally decide which events to add via add(). This ensures business logic encapsulation and simplifies testing.
- Do not wrap emit() calls in try-catch blocks. The emit() method is already safe and handles errors internally. Adding try-catch around emit() is redundant and creates unnecessary complexity.

## What Not to Do
- Don't generate events directly from view - use bloc methods
- Don't wrap emit() calls in try-catch
- Don't mix BlocBuilder with setState in the same widget
- Don't use setState inside BLoC/Cubit
- Don't mix different state management approaches in the same widget

## Flutter Built-in State Management (Explicit Request Only)

When simple state management is explicitly requested or for simple use cases:

- **Built-in Solutions:** Use Flutter's built-in state management solutions for simple, local state. Do not use a third-party package unless explicitly requested.
- **Streams:** Use `Stream`s and `StreamBuilder` for handling a sequence of asynchronous events.
- **Futures:** Use `Future`s and `FutureBuilder` for handling a single asynchronous operation that will complete in the future.
- **ValueNotifier:** Use `ValueNotifier` with `ValueListenableBuilder` for simple, local state that involves a single value.

```dart
// Define a ValueNotifier to hold the state.
final ValueNotifier<int> _counter = ValueNotifier<int>(0);

// Use ValueListenableBuilder to listen and rebuild.
ValueListenableBuilder<int>(
  valueListenable: _counter,
  builder: (context, value, child) {
    return Text('Count: $value');
  },
);
```

- **ChangeNotifier:** For state that is more complex or shared across multiple widgets, use `ChangeNotifier`.
- **ListenableBuilder:** Use `ListenableBuilder` to listen to changes from a `ChangeNotifier` or other `Listenable`.
- **MVVM:** When a more robust solution is needed, structure the app using the Model-View-ViewModel (MVVM) pattern.
- **Dependency Injection:** Use simple manual constructor dependency injection to make a class's dependencies explicit in its API, and to manage dependencies between different layers of the application.
- **Provider:** If a dependency injection solution beyond manual constructor injection is explicitly requested, `provider` can be used to make services, repositories, or complex state objects available to the UI layer without tight coupling (note: this document generally defaults against third-party packages for state management unless explicitly requested).