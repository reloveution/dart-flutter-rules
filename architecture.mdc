---
description: "Clean Architecture principles and layer separation for Flutter applications. Covers Result<T> error handling, layer dependencies, polymorphism over conditionals, and proper separation of concerns."
globs:
alwaysApply: true
---

# Architecture Rules

## Architectural Guidelines
- Design for extension and modification without breaking existing code.
- Create loosely coupled, highly cohesive modules.
- Implement proper separation of concerns at all levels.
- Implement proper abstraction layers to hide implementation details.

## Application Architecture
- **Separation of Concerns:** Aim for separation of concerns similar to MVC/MVVM, with defined Model, View, and ViewModel/Controller roles.
- **Logical Layers:** Organize the project into logical layers:
  - Presentation (widgets, screens)
  - Domain (business logic classes)
  - Data (model classes, API clients)
  - Core (shared classes, utilities, and extension types)
- **Feature-based Organization:** For larger projects, organize code by feature, where each feature has its own presentation, domain, and data subfolders. This improves navigability and scalability.
- **Feature Folder Example:** Group every feature under its own folder (for example, `auth/` with `auth_bloc.dart`, `login_usecase.dart`, `login_screen.dart`, `logout_button.dart`) so presentation, domain, and data pieces stay co-located.
- Allow communication only between adjacent layers; presentation never reaches data directly, and data must not depend on UI code.
- Treat repositories as the single source of truth: they coordinate services/datasources and perform the only mutations, while view models/controllers consume read-only projections.

## Error Handling
- Use Result<T> for all business logic error handling. Use runZonedGuarded for critical measurement operations. Use try/catch for additional protection within zones. This creates multi-level error protection for scientific data integrity.
- All services, repositories, use cases, and controllers must communicate through Result<T> wrapper. Never throw exceptions in business logic.

## Async Design
- Write all methods in controllers, use cases, repositories, and datasources as Future from the start to avoid rewriting interfaces. Only keep truly synchronous operations synchronous.

## Code Organization
- Excessive if-else/switch-case logic indicates poor architecture and creates maintenance issues. Minimize conditional logic in favor of polymorphism and design patterns.
- Use object methods or factories instead of multiple conditional statements.
- Group related logic into separate methods and classes. Keep main classes focused on coordination rather than implementation details.
- Implement proper separation between domain, data, and presentation layers

## Layer Boundaries
- Keep UI layer clean of business logic. UI should only display data and handle user interactions. Move calculations, validations, and business rules to controllers, use cases, or services.

# Layer Dependencies Rules
- Repositories depend on DataSources/Services through constructor interfaces
- Use Cases depend on Repositories through constructor interfaces  
- Controllers depend on Use Cases through constructor interfaces
- Use Cases can be shared across different feature controllers
- Use Cases can depend on other Use Cases through constructor interfaces
- Data parsing should be performed in the repository layer. DataSources should return raw data, repositories handle parsing and transformation.

## Project Structure
- **Standard Structure:** Assumes a standard Flutter project structure with `lib/main.dart` as the primary application entry point.

## Code Structure
- **Separation of Concerns:** Adhere to maintainable code structure and separation of concerns. UI logic should be separate from business logic.
